[{"title":"将自己的库上传到cocopods","slug":"iOS/将自己的库上传到cocopods","date":"2017-07-09T16:00:00.000Z","updated":"2017-07-18T14:08:08.000Z","comments":true,"path":"2017/07/10/iOS/将自己的库上传到cocopods/","link":"","permalink":"http://yoursite.com/2017/07/10/iOS/将自己的库上传到cocopods/","excerpt":"升级版本 12$sudo gem install cocoa podspod setup 注册 1pod trunk register 252289287@qq.com &apos;Aiden&apos; --verbose 注册完成可以查看信息 1pod trunk me","text":"升级版本 12$sudo gem install cocoa podspod setup 注册 1pod trunk register 252289287@qq.com &apos;Aiden&apos; --verbose 注册完成可以查看信息 1pod trunk me 创建.spec文件 1pod spec create DHCalendarView 打开DHCalendarView.podspec填写信息 123456789101112131415Pod::Spec.new do |s|s.name = &quot;DHCalendarView&quot;s.version = &quot;1.0.4&quot;s.summary = &quot;日历&quot;s.description = &lt;&lt;-DESC好用的日历DESCs.homepage = &quot;https://github.com/DajuanM/DHCalendarView&quot;s.license = &quot;MIT&quot;s.author = &#123; &quot;Aiden&quot; =&gt; &quot;252289287@qq.com&quot; &#125;s.source = &#123; :git =&gt; &quot;https://github.com/DajuanM/DHCalendarView.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;s.source_files = &quot;DHCalendarView&quot;,&quot;DHCalendarView/**/*.&#123;h,m&#125;&quot;s.requires_arc = trues.ios.deployment_target = &apos;8.0&apos;end 所有的符号必须\u0010要是英文符号，不然会报错 这中间可能会报一些错误，根据提示解决就好了 忽略警告 1pod lib lint --allow-warnings 验证文件是否编写正确 1pod lib lint DHCalendarView.podspec 创建tag 12git tag &apos;1.0.4&apos;git push --tags 把编写的文件告诉cocopods 1pod trunk push DHCalendarView.podspec 出现以下信息就算成功了 错误： 解决方法 1pod trunk push DHCalendarView.podspec --allow-warnings","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"React Native环境搭建","slug":"React-Native/React-Native环境搭建","date":"2017-06-14T16:00:00.000Z","updated":"2017-06-15T12:03:34.000Z","comments":true,"path":"2017/06/15/React-Native/React-Native环境搭建/","link":"","permalink":"http://yoursite.com/2017/06/15/React-Native/React-Native环境搭建/","excerpt":"安装Node.js官网:https://nodejs.org/en/ 安装Homebrewruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装watchmanbrew install watchman 安装flowbrew install flow","text":"安装Node.js官网:https://nodejs.org/en/ 安装Homebrewruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装watchmanbrew install watchman 安装flowbrew install flow 安装nvmbrew install nvm 安装React Native命令行工具npm install -g react-native-cli 创建React Native项目 cd 项目存放文件夹 react-native init 项目名 react-native run-ios / react-native run-andriod 代码提示https://github.com/virtoolswebplayer/ReactNative-LiveTemplate","categories":[],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"LeetCode-561 Array Partition I","slug":"算法/LeetCode-561-Array-Partition-I","date":"2017-06-14T16:00:00.000Z","updated":"2017-06-15T14:10:56.000Z","comments":true,"path":"2017/06/15/算法/LeetCode-561-Array-Partition-I/","link":"","permalink":"http://yoursite.com/2017/06/15/算法/LeetCode-561-Array-Partition-I/","excerpt":"题目Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.Example 1:Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).","text":"题目Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.Example 1:Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note:n is a positive integer, which is in the range of [1, 10000].All the integers in the array will be in the range of [-10000, 10000]. Subscribe to see which companies asked this question. 代码1234567891011121314func arrayPairSum(_ nums: [Int]) -&gt; Int &#123; guard nums.count % 2 == 0 else &#123; return 0 &#125; var arr = nums arr.sort() var sum = 0 for i in 0..&lt;arr.count &#123; if i % 2 == 0 &#123; sum += arr[i] &#125; &#125; return sum&#125;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://yoursite.com/tags/算法题/"}]},{"title":"LeetCode-566 Reshape the Matrix","slug":"算法/LeetCode-566-Reshape-the-Matrix","date":"2017-06-14T16:00:00.000Z","updated":"2017-06-15T14:11:02.000Z","comments":true,"path":"2017/06/15/算法/LeetCode-566-Reshape-the-Matrix/","link":"","permalink":"http://yoursite.com/2017/06/15/算法/LeetCode-566-Reshape-the-Matrix/","excerpt":"题目In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1:Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.","text":"题目In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1:Input: nums = [[1,2], [3,4]]r = 1, c = 4Output: [[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example 2:Input: nums = [[1,2], [3,4]]r = 2, c = 4Output: [[1,2], [3,4]]Explanation:There is no way to reshape a 2 2 matrix to a 2 4 matrix. So output the original matrix. Note:The height and width of the given matrix is in range [1, 100].The given r and c are all positive. Subscribe to see which companies asked this question. 代码123456789101112131415func matrixReshape(_ nums: [[Int]], _ r: Int, _ c: Int) -&gt; [[Int]] &#123; var tmp: [Int] = nums.flatMap&#123;$0&#125; guard tmp.count % (r * c) == 0 else &#123; return nums &#125; var arr: [[Int]] = [] for i in 0..&lt;r &#123; var t: [Int] = [] for j in 0..&lt;c &#123; t.append(tmp[i*c+j]) &#125; arr.append(t) &#125; return arr&#125;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://yoursite.com/tags/算法题/"}]},{"title":"LeetCode-485. Max Consecutive Ones","slug":"算法/LeetCode-485-Max-Consecutive-Ones","date":"2017-06-14T16:00:00.000Z","updated":"2017-06-15T14:10:51.000Z","comments":true,"path":"2017/06/15/算法/LeetCode-485-Max-Consecutive-Ones/","link":"","permalink":"http://yoursite.com/2017/06/15/算法/LeetCode-485-Max-Consecutive-Ones/","excerpt":"Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: 123Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s.The maximum number of consecutive 1s is 3.","text":"Given a binary array, find the maximum number of consecutive 1s in this array. Example 1: 123Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s.The maximum number of consecutive 1s is 3. Note:** The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 Subscribe to see which companies asked this question. 12345678910111213141516func findMaxConsecutiveOnes(_ nums: [Int]) -&gt; Int &#123; var count = 0,maxCount = 0 var i = 0 while i &lt; nums.count &#123; while i &lt; nums.count &amp;&amp; nums[i] == 1&#123; count += 1 i += 1 &#125; if count &gt; maxCount &#123; maxCount = count &#125; count = 0 i += 1 &#125; return maxCount&#125;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://yoursite.com/tags/算法题/"}]},{"title":"LeetCode-605. Can Place Flowers","slug":"算法/LeetCode-605-Can-Place-Flowers","date":"2017-06-14T16:00:00.000Z","updated":"2017-06-15T14:11:11.000Z","comments":true,"path":"2017/06/15/算法/LeetCode-605-Can-Place-Flowers/","link":"","permalink":"http://yoursite.com/2017/06/15/算法/LeetCode-605-Can-Place-Flowers/","excerpt":"题目Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.Example 1:Input: flowerbed = [1,0,0,0,1], n = 1Output: True","text":"题目Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.Example 1:Input: flowerbed = [1,0,0,0,1], n = 1Output: True Example 2:Input: flowerbed = [1,0,0,0,1], n = 2Output: False Note:The input array won’t violate no-adjacent-flowers rule.The input array size is in the range of [1, 20000].n is a non-negative integer which won’t exceed the input array size. Subscribe to see which companies asked this question. 代码1234567891011121314func canPlaceFlowers(_ flowerbed: [Int], _ n: Int) -&gt; Bool &#123; var count: Int = 0 var arr = flowerbed for i in 0..&lt;arr.count &#123; if (arr[i] == 0 &amp;&amp; (i == 0 || arr[i - 1] == 0) &amp;&amp; (i == arr.count - 1 || arr[i + 1] == 0)) &#123; arr[i] = 1 count += 1 &#125; if count &gt;= n &#123; return true &#125; &#125; return false &#125;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://yoursite.com/tags/算法题/"}]},{"title":"LeetCode-581. Shortest Unsorted Continuous Subarray","slug":"算法/LeetCode-581-Shortest-Unsorted-Continuous-Subarray","date":"2017-06-14T16:00:00.000Z","updated":"2017-06-15T14:11:07.000Z","comments":true,"path":"2017/06/15/算法/LeetCode-581-Shortest-Unsorted-Continuous-Subarray/","link":"","permalink":"http://yoursite.com/2017/06/15/算法/LeetCode-581-Shortest-Unsorted-Continuous-Subarray/","excerpt":"题目Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.You need to find the shortest such subarray and output its length.Example 1:Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.","text":"题目Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.You need to find the shortest such subarray and output its length.Example 1:Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order. Note:Then length of the input array is in range [1, 10,000].The input array may contain duplicates, so ascending order here means &lt;=. Subscribe to see which companies asked this question. 代码1234567891011121314func findUnsortedSubarray(_ nums: [Int]) -&gt; Int &#123; var arr = nums arr.sort() var start = 0 var end = nums.count - 1 while start &lt; nums.count &amp;&amp; nums[start] == arr[start] &#123; start += 1 &#125; while end &gt; start &amp;&amp; nums[end] == arr[end] &#123; end -= 1 &#125; return end - start + 1&#125;","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://yoursite.com/tags/算法题/"}]},{"title":"UITableView长按拖动排序（支持不同行高间交换）","slug":"iOS/UITableView长按拖动排序（支持不同行高间交换）","date":"2017-06-08T16:00:00.000Z","updated":"2017-06-15T12:09:12.000Z","comments":true,"path":"2017/06/09/iOS/UITableView长按拖动排序（支持不同行高间交换）/","link":"","permalink":"http://yoursite.com/2017/06/09/iOS/UITableView长按拖动排序（支持不同行高间交换）/","excerpt":"效果图： github下载地址：DHDragableCellTableView 使用将tableView继承与DHDragableCellTableView并遵循协议DHDragableCellTableViewDataSource,DHDragableCellTableViewDelegate 123456789#pragma mark - DHDragableCellTableViewDataSource- (NSArray *)dataSourceArrayInTableView:(DHDragableCellTableView *)tableView&#123; return self.dataSource.copy;//数据源&#125;- (void)tableView:(DHDragableCellTableView *)tableView newDataSourceArrayAfterMove:(NSArray *)newDataSourceArray&#123; self.dataSource = newDataSourceArray.mutableCopy;//返回的数据源 [self.tableView reloadData];&#125;","text":"效果图： github下载地址：DHDragableCellTableView 使用将tableView继承与DHDragableCellTableView并遵循协议DHDragableCellTableViewDataSource,DHDragableCellTableViewDelegate 123456789#pragma mark - DHDragableCellTableViewDataSource- (NSArray *)dataSourceArrayInTableView:(DHDragableCellTableView *)tableView&#123; return self.dataSource.copy;//数据源&#125;- (void)tableView:(DHDragableCellTableView *)tableView newDataSourceArrayAfterMove:(NSArray *)newDataSourceArray&#123; self.dataSource = newDataSourceArray.mutableCopy;//返回的数据源 [self.tableView reloadData];&#125; 实现：大概思路，为UITableView添加长按手势，长按后给选择的cell截图并隐藏选择的cell,让截图跟随手势移动 添加手势 123456789/** 添加手势 */- (void)dh_addGesture&#123; _gesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(dh_processGesture:)]; _gesture.minimumPressDuration = _gestureMinimumPressDuration; [self addGestureRecognizer:_gesture];&#125; 监听手势状态 12345678910111213141516171819202122232425- (void)dh_processGesture:(UILongPressGestureRecognizer *)gesture&#123; switch (gesture.state) &#123; case UIGestureRecognizerStateBegan: &#123; [self dh_gestureBegan:gesture]; &#125; break; case UIGestureRecognizerStateChanged: &#123; if (!_canEdgeScroll) &#123; [self dh_gestureChanged:gesture]; &#125; &#125; break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: &#123; [self dh_gestureEndedOrCancelled:gesture]; &#125; break; default: break; &#125;&#125; 开始拖动 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)dh_gestureBegan:(UILongPressGestureRecognizer *)gesture&#123; CGPoint point = [gesture locationInView:gesture.view]; self.lastPoint = point; NSIndexPath *selectedIndexPath = [self indexPathForRowAtPoint:point]; if (!selectedIndexPath) &#123; return; &#125; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(tableView:willMoveCellAtIndexPath:)]) &#123; [self.delegate tableView:self willMoveCellAtIndexPath:selectedIndexPath]; &#125; if (_canEdgeScroll) &#123; //开启边缘滚动 [self dh_startEdgeScroll]; &#125; //每次移动开始获取一次数据源 if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(dataSourceArrayInTableView:)]) &#123; _tempDataSource = [self.dataSource dataSourceArrayInTableView:self].mutableCopy; &#125; _selectedIndexPath = selectedIndexPath; UITableViewCell *cell = [self cellForRowAtIndexPath:selectedIndexPath]; _tempView = [self dh_snapshotViewWithInputView:cell]; if (_drawMovalbeCellBlock) &#123; //将_tempView通过block让使用者自定义 _drawMovalbeCellBlock(_tempView); &#125;else &#123; //配置默认样式 _tempView.layer.shadowColor = [UIColor grayColor].CGColor; _tempView.layer.masksToBounds = NO; _tempView.layer.cornerRadius = 0; _tempView.layer.shadowOffset = CGSizeMake(-5, 0); _tempView.layer.shadowOpacity = 0.4; _tempView.layer.shadowRadius = 5; &#125; _tempView.frame = cell.frame; [self addSubview:_tempView]; //隐藏cell cell.hidden = YES; [UIView animateWithDuration:kDH_DragableCellAnimationTime animations:^&#123; _tempView.center = CGPointMake(_tempView.center.x, point.y); &#125;];&#125; 拖动 这里的_toBottom是int类型用来判断手势是向哪一个方向拖动，然后根据拖动的cell跟要交换的cell的中心点进行比较，判断是否交换 1234567891011121314151617181920212223242526272829- (void)dh_gestureChanged:(UILongPressGestureRecognizer *)gesture&#123; CGPoint point = [gesture locationInView:gesture.view]; //判断拖动的方向 if (point.y - self.lastPoint.y &gt; 0) &#123; _toBottom = 1;//向下拖 &#125;else if(point.y - self.lastPoint.y &lt; 0)&#123; _toBottom = -1;//向上拖 &#125;else&#123; _toBottom = 0; &#125; self.lastPoint = point; NSIndexPath *currentIndexPath = [self indexPathForRowAtPoint:point]; if (currentIndexPath &amp;&amp; ![_selectedIndexPath isEqual:currentIndexPath]) &#123; UITableViewCell *cell = [self cellForRowAtIndexPath:_selectedIndexPath]; UITableViewCell *cell1 = [self cellForRowAtIndexPath:currentIndexPath]; //将拖动的cell跟要交换的cell的centerY进行比较 if ((_toBottom == 1 &amp;&amp; (point.y+cell.frame.size.height/2) &gt;= CGRectGetMaxY(cell1.frame) &amp;&amp; (CGRectGetMaxY(cell1.frame) &gt;= CGRectGetMaxY(cell.frame))) || ((_toBottom == -1 &amp;&amp; (point.y-cell.frame.size.height/2) &lt;= CGRectGetMinY(cell1.frame)) &amp;&amp; (CGRectGetMinY(cell1.frame) &lt;= CGRectGetMinY(cell.frame)))) &#123; //交换数据源和cell [self dh_updateDataSourceAndCellFromIndexPath:_selectedIndexPath toIndexPath:currentIndexPath]; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(tableView:didMoveCellFromIndexPath:toIndexPath:)]) &#123; [self.delegate tableView:self didMoveCellFromIndexPath:_selectedIndexPath toIndexPath:currentIndexPath]; &#125; _selectedIndexPath = currentIndexPath; &#125; &#125; //让截图跟随手势 _tempView.center = CGPointMake(_tempView.center.x, point.y);&#125; 交换数据跟cell的位置 为了在不同行高交换时cell不变形，交换后要立刻reloadData，再通过对两个cell截图，用截图来模拟交换的动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 交换数据源 跟 cell的位置 */- (void)dh_updateDataSourceAndCellFromIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath&#123; if ([self numberOfSections] == 1) &#123; //只有一组 [_tempDataSource exchangeObjectAtIndex:fromIndexPath.row withObjectAtIndex:toIndexPath.row]; //交换cell [self moveRowAtIndexPath:fromIndexPath toIndexPath:toIndexPath]; &#125;else &#123; //有多组 id fromData = _tempDataSource[fromIndexPath.section][fromIndexPath.row]; id toData = _tempDataSource[toIndexPath.section][toIndexPath.row]; NSMutableArray *fromArray = [_tempDataSource[fromIndexPath.section] mutableCopy]; NSMutableArray *toArray = [_tempDataSource[toIndexPath.section] mutableCopy]; [fromArray replaceObjectAtIndex:fromIndexPath.row withObject:toData]; [toArray replaceObjectAtIndex:toIndexPath.row withObject:fromData]; [_tempDataSource replaceObjectAtIndex:fromIndexPath.section withObject:fromArray]; [_tempDataSource replaceObjectAtIndex:toIndexPath.section withObject:toArray]; //交换cell [self beginUpdates]; [self moveRowAtIndexPath:fromIndexPath toIndexPath:toIndexPath]; [self moveRowAtIndexPath:toIndexPath toIndexPath:fromIndexPath]; [self endUpdates]; &#125; //交换数据源后reloadData [self reloadData]; //返回交换后的数据源 if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(tableView:newDataSourceArrayAfterMove:)]) &#123; [self.dataSource tableView:self newDataSourceArrayAfterMove:_tempDataSource.copy]; &#125; //此处用两个cell的截图实现交换的动画 UITableViewCell *cell = [self cellForRowAtIndexPath:fromIndexPath]; cell.hidden = NO; UITableViewCell *cell1 = [self cellForRowAtIndexPath:toIndexPath]; cell1.hidden = YES; UIView *tmpCell = [self dh_snapshotViewWithInputView:cell]; cell.hidden = YES; tmpCell.frame = cell1.frame; if (_toBottom == -1) &#123;//向上 tmpCell.frame = CGRectMake(0, CGRectGetMinY(cell1.frame), cell.frame.size.width, cell.frame.size.height); [self insertSubview:tmpCell belowSubview:_tempView]; &#125;else if (_toBottom == 1) &#123;//向下 tmpCell.frame = CGRectMake(0, CGRectGetMaxY(cell1.frame)-cell.frame.size.height, cell.frame.size.width, cell.frame.size.height); [self insertSubview:tmpCell belowSubview:_tempView]; &#125;else&#123; &#125; [UIView animateWithDuration:0.2 animations:^&#123; tmpCell.frame = cell.frame; &#125;completion:^(BOOL finished) &#123; cell.hidden = NO; [tmpCell removeFromSuperview]; &#125;];&#125; 边缘滚动处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)dh_startEdgeScroll&#123; _edgeScrollTimer = [CADisplayLink displayLinkWithTarget:self selector:@selector(dh_processEdgeScroll)]; [_edgeScrollTimer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)dh_processEdgeScroll&#123; [self dh_gestureChanged:_gesture]; CGFloat minOffsetY = self.contentOffset.y + _edgeScrollRange; CGFloat maxOffsetY = self.contentOffset.y + self.bounds.size.height - _edgeScrollRange; CGPoint touchPoint = _tempView.center; //处理上下达到极限之后不再滚动tableView，其中处理了滚动到最边缘的时候，当前处于edgeScrollRange内，但是tableView还未显示完，需要显示完tableView才停止滚动 if (touchPoint.y &lt; _edgeScrollRange) &#123; if (self.contentOffset.y &lt;= 0) &#123; return; &#125;else &#123; if (self.contentOffset.y - 1 &lt; 0) &#123; return; &#125; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y - 1) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y - 1); &#125; &#125; if (touchPoint.y &gt; self.contentSize.height - _edgeScrollRange) &#123; if (self.contentOffset.y &gt;= self.contentSize.height - self.bounds.size.height) &#123; return; &#125;else &#123; if (self.contentOffset.y + 1 &gt; self.contentSize.height - self.bounds.size.height) &#123; return; &#125; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y + 1) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y + 1); &#125; &#125; //处理滚动 CGFloat maxMoveDistance = 20; if (touchPoint.y &lt; minOffsetY) &#123; //cell在往上移动 CGFloat moveDistance = (minOffsetY - touchPoint.y)/_edgeScrollRange*maxMoveDistance; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y - moveDistance) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y - moveDistance); &#125;else if (touchPoint.y &gt; maxOffsetY) &#123; //cell在往下移动 CGFloat moveDistance = (touchPoint.y - maxOffsetY)/_edgeScrollRange*maxMoveDistance; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y + moveDistance) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y + moveDistance); &#125;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS开发输入框字数限制","slug":"iOS/iOS开发输入框字数限制","date":"2017-05-22T16:00:00.000Z","updated":"2017-06-15T12:05:34.000Z","comments":true,"path":"2017/05/23/iOS/iOS开发输入框字数限制/","link":"","permalink":"http://yoursite.com/2017/05/23/iOS/iOS开发输入框字数限制/","excerpt":"在在网上查了资料，\u0010很多都是下面这个方法，但是在原生键盘上是有问题的，当当在手机上英文九宫格连点的时候，会替换掉最后的文字","text":"在在网上查了资料，\u0010很多都是下面这个方法，但是在原生键盘上是有问题的，当当在手机上英文九宫格连点的时候，会替换掉最后的文字 123456789101112131415161718192021222324252627282930313233343536373839404142[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(textFieldEditChanged:) name:@&quot;UITextFieldTextDidChangeNotification&quot; object:myTextField];-(void)textFieldEditChanged:(NSNotification *)obj&#123; UITextField *textField = (UITextField *)obj.object; NSString *toBeString = textField.text; NSString *lang = [textField.textInputMode primaryLanguage]; if ([lang isEqualToString:@&quot;zh-Hans&quot;])// 简体中文输入 &#123; //获取高亮部分 UITextRange *selectedRange = [textField markedTextRange]; UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0]; // 没有高亮选择的字，则对已输入的文字进行字数统计和限制 if (!position) &#123; if (toBeString.length &gt; MAX_STARWORDS_LENGTH) &#123; textField.text = [toBeString substringToIndex:MAX_STARWORDS_LENGTH]; &#125; &#125; &#125; // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况 else &#123; if (toBeString.length &gt; MAX_STARWORDS_LENGTH) &#123; NSRange rangeIndex = [toBeString rangeOfComposedCharacterSequenceAtIndex:MAX_STARWORDS_LENGTH]; if (rangeIndex.length == 1) &#123; textField.text = [toBeString substringToIndex:MAX_STARWORDS_LENGTH]; &#125; else &#123; NSRange rangeRange = [toBeString rangeOfComposedCharacterSequencesForRange:NSMakeRange(0, MAX_STARWORDS_LENGTH)]; textField.text = [toBeString substringWithRange:rangeRange]; &#125; &#125; &#125;&#125; 经过多次测试后，终于解决了，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static const int nameMaxLength = 6;@interface FCEditNameViewController ()&lt;UITextFieldDelegate&gt;@property (strong, nonatomic) IBOutlet UITextField *nameTextField;@property (nonatomic, strong) NSString *oldStr;//记录修改之前的值@property (nonatomic, strong) NSString *positionStr;记录高亮的文字@end//当前光标位置 range.location //已选文字长度 range.length - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; if ([string isEqualToString:@&quot;&quot;]) &#123; return YES; &#125; //获取高亮部分 UITextRange *selectedRange = [textField markedTextRange]; UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0]; if (!position) &#123; self.oldStr = textField.text; if (range.length + range.location &gt; textField.text.length) &#123; return NO; &#125; NSInteger newStrLength = [textField.text length] + [string length] - range.length; if (newStrLength &lt;= nameMaxLength) &#123; return YES; &#125;else&#123; return NO; &#125; &#125;else&#123; if ([self IsChinese:string]) &#123; NSString *str = [NSString stringWithFormat:@&quot;%@%@&quot;,self.oldStr,string]; self.oldStr = @&quot;&quot;; if (str.length &gt; nameMaxLength) &#123; return NO; &#125;else&#123; return YES; &#125; &#125; &#125; return YES;&#125;//判断是否有中文- (BOOL)IsChinese:(NSString *)str &#123; for(int i=0; i&lt; [str length];i++)&#123; int a = [str characterAtIndex:i]; if( a &gt; 0x4e00 &amp;&amp; a &lt; 0x9fff) &#123; return YES; &#125; &#125; return NO;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Xcode打断点调试时所有的变量都为nil","slug":"iOS/Xcode打断点调试时所有的变量都为nil","date":"2017-05-19T16:00:00.000Z","updated":"2017-06-15T12:19:34.000Z","comments":true,"path":"2017/05/20/iOS/Xcode打断点调试时所有的变量都为nil/","link":"","permalink":"http://yoursite.com/2017/05/20/iOS/Xcode打断点调试时所有的变量都为nil/","excerpt":"今天开发的\u0010时候打断点进行调试，结果控制台上显示的变量都是nil,例: 解决办法，如图：","text":"今天开发的\u0010时候打断点进行调试，结果控制台上显示的变量都是nil,例: 解决办法，如图： 将Optimization Level 设为none","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"AFNetworking的requestSerializer跟responseSerializer","slug":"iOS/AFNetworking的requestSerializer跟responseSerializer","date":"2017-05-15T16:00:00.000Z","updated":"2017-06-15T12:05:28.000Z","comments":true,"path":"2017/05/16/iOS/AFNetworking的requestSerializer跟responseSerializer/","link":"","permalink":"http://yoursite.com/2017/05/16/iOS/AFNetworking的requestSerializer跟responseSerializer/","excerpt":"","text":"requestSerializerrequestSerializer它是AFNetworking参数编码的序列化器： AFHTTPRequestSerializer普通的http的编码格式，二进制 AFJSONRequestSerializerjson编码格式 AFPropertyListRequestSerializerplist编码格式 responseSerializerresponseSerializer它是AFNetworking返回内容编码的序列化器： AFHTTPResponseSerializer普通的http的编码格式，二进制 AFJSONResponseSerializer json编码格式 AFXMLParserRequestSerializer plist编码格式 AFXMLDocumentResponseSerializer XML,只能返回XMLParser，还需要自己解析 AFPropertyListRequestSerializer plist编码格式 AFImageResponseSerializer image AFCompoundRequestSerializer 组合","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"jQuery的使用","slug":"web/jQuery的使用","date":"2017-04-25T16:00:00.000Z","updated":"2017-06-15T12:04:55.000Z","comments":true,"path":"2017/04/26/web/jQuery的使用/","link":"","permalink":"http://yoursite.com/2017/04/26/web/jQuery的使用/","excerpt":"jQuery DOM操作 jQuery 获取123456$(\"#btn1\").click(function()&#123; alert(\"Text: \" + $(\"#test\").text());&#125;);$(\"#btn2\").click(function()&#123; alert(\"HTML: \" + $(\"#test\").html());&#125;); 亲自试一试 jQuery 设置123456789$(\"#btn1\").click(function()&#123; $(\"#test1\").text(\"Hello world!\");&#125;);$(\"#btn2\").click(function()&#123; $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");&#125;);$(\"#btn3\").click(function()&#123; $(\"#test3\").val(\"Dolly Duck\");&#125;); 亲自试一试","text":"jQuery DOM操作 jQuery 获取123456$(\"#btn1\").click(function()&#123; alert(\"Text: \" + $(\"#test\").text());&#125;);$(\"#btn2\").click(function()&#123; alert(\"HTML: \" + $(\"#test\").html());&#125;); 亲自试一试 jQuery 设置123456789$(\"#btn1\").click(function()&#123; $(\"#test1\").text(\"Hello world!\");&#125;);$(\"#btn2\").click(function()&#123; $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");&#125;);$(\"#btn3\").click(function()&#123; $(\"#test3\").val(\"Dolly Duck\");&#125;); 亲自试一试 jQuery 添加 append() - 在被选元素内的结尾插入内容 1$(\"p\").append(\"Some appended text.\"); 亲自试一试 prepend() - 在被选元素内的开头插入内容 1$(\"p\").prepend(\"Some prepended text.\"); 亲自试一试 after() - 在被选元素之后插入内容 1$(\"img\").after(\"Some text after\"); 亲自试一试 before() - 在被选元素之前插入内容 1$(\"img\").before(\"Some text before\"); 亲自试一试 jQuery 删除 remove() - 删除被选元素（及其子元素） 1$(\"#div1\").remove(); 亲自试一试 empty() - 从被选元素中删除子元素 1$(\"#div1\").empty(); 亲自试一试 jQuery css()设置css属性 1$(\"p\").css(\"background-color\"); 亲自试一试 设置多个css属性 1$(\"p\").css(&#123;\"background-color\":\"yellow\",\"font-size\":\"200%\"&#125;); 亲自试一试 jQuery 效果 jQuery 隐藏/显示1234567$(\"#hide\").click(function()&#123; $(\"p\").hide();&#125;);$(\"#show\").click(function()&#123; $(\"p\").show();&#125;); 亲自试一试 jQuery 淡入淡出 fadeIn() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000);&#125;); 亲自试一试 fadeOut() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeOut(); $(\"#div2\").fadeOut(\"slow\"); $(\"#div3\").fadeOut(3000);&#125;); 亲自试一试 fadeToggle() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000);&#125;); 亲自试一试 fadeTo() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeTo(\"slow\",0.15); $(\"#div2\").fadeTo(\"slow\",0.4); $(\"#div3\").fadeTo(\"slow\",0.7);&#125;); 亲自试一试 jQuery 滑动 slideDown() slideUp() slideToggle() ​ ​","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"hexo主题代码怎么高亮显示","slug":"other/hexo主题代码怎么高亮显示","date":"2017-03-06T16:00:00.000Z","updated":"2017-06-15T12:04:34.000Z","comments":true,"path":"2017/03/07/other/hexo主题代码怎么高亮显示/","link":"","permalink":"http://yoursite.com/2017/03/07/other/hexo主题代码怎么高亮显示/","excerpt":"看到很多人跟我一样在按照hexo主题官方文档配置后，结果代码还是不能高亮显示。觉得将它记录下来希望能帮助到刚喜欢用博客来记录东西的朋友。 代码块需要用到两个```,在第一个后面需要加上代码的语言 如图 常用语言对应表","text":"看到很多人跟我一样在按照hexo主题官方文档配置后，结果代码还是不能高亮显示。觉得将它记录下来希望能帮助到刚喜欢用博客来记录东西的朋友。 代码块需要用到两个```,在第一个后面需要加上代码的语言 如图 常用语言对应表 语言 对应代码 Bash bash,sh,zsh C# cs,csharp C++ cpp,c,cc,h,c++,h++,hop CSS css DOS dos,bat,cmd HTML,XML xml,html,xhtml,rss,atom,xjb,xsd,ssl,plist JSON json java java JavaScript javascript, js, jsx Objective-C objectivec, mm, objc, obj-c PHP php, php3, php4, php5, php6 Ruby ruby, rb, gemspec, podspec, thor, irb SQL sql Swift swift VB.Net vbnet, vb","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]},{"title":"iOS中内存泄漏调试","slug":"iOS/iOS内存泄漏","date":"2017-02-20T10:01:22.000Z","updated":"2017-06-15T12:06:34.000Z","comments":true,"path":"2017/02/20/iOS/iOS内存泄漏/","link":"","permalink":"http://yoursite.com/2017/02/20/iOS/iOS内存泄漏/","excerpt":"iOS开发中，内存问题一直是个长久不变的问题。这不，项目间歇间，用xcode自带的Leak跑了一下程序，发现了几个内存泄漏的地方，都是平时自己没有注意到的，并做出相应改正。在这里记录下。 1.运行程序让程序先跑起来 2.进入Leak工具 如上图，选中show the debug（箭头指的），然后点击Memory","text":"iOS开发中，内存问题一直是个长久不变的问题。这不，项目间歇间，用xcode自带的Leak跑了一下程序，发现了几个内存泄漏的地方，都是平时自己没有注意到的，并做出相应改正。在这里记录下。 1.运行程序让程序先跑起来 2.进入Leak工具 如上图，选中show the debug（箭头指的），然后点击Memory 然后点击profile in instruments,通过Leak重新运行程序(弹出框中选择Restart 3.操作Leak工具 如上图，此时程序在跑起来了，Leak Checks右边显示绿色的钩，表示当前没有内存泄漏，这时候我们就可以操作我的app了，跑起来吧，直到发现有红色的X，表示在这里有内存泄漏，如下图 点击红色X，选择Call Tree，如下图 这时候下面的列表会出来很多方法，但都是系统的，表示看不懂有木有啊。。。这时候点击右边中间的选项，然后勾选Call Tree下的Separate by Thread 和 Hide System Libraries，如下图 然后再看左右，下面列表的方法就会变成了我们自己写的方法了，如下图 在这里，有的人肯定会有疑问，为啥他的列表里的方法都是一些进制类的看不懂的，或者就是空白，这是因为Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件。显示进制是因为我们的工程build settings 的问题，没有生成dSYM 文件，也就无法解析debug symbols。做法如下图 在Build Options将Debug information Format选择dsYM，这里默认的可能是release下选择的，将debug下也选择就可以了。然后重新从编译，重新运行，从第一步重新走一遍即可出来最后双击列表中暴露出来的方法，会直接显示代码，神不神奇~ 利用这个调试方法，里里外外将我们程序跑一跑，将内存泄漏的地方都改过来，这样程序闪退的机率将会大大减小。 关于product-&gt;analyze分析内存泄漏的问题优点：分析速度快，并且可以对所有的代码进行内存分析缺点：分析结果不一定准确（没有运行程序，根据代码的上下文语法结构）所以最好还是用Leak工具进行动态运行检查。 路漫漫其修远兮，吾将上下而求索，与君互勉。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"一行代码解决NavigationController多次push问题","slug":"iOS/一行代码解决NavigationController多次push问题","date":"2017-01-20T03:26:00.000Z","updated":"2017-06-15T12:05:20.000Z","comments":true,"path":"2017/01/20/iOS/一行代码解决NavigationController多次push问题/","link":"","permalink":"http://yoursite.com/2017/01/20/iOS/一行代码解决NavigationController多次push问题/","excerpt":"新建文件如下 UINavigationController+PushSafe.h 123456#import &lt;UIKit/UIKit.h&gt;@interface UINavigationController(PushSafe)-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated safe:(BOOL)safe;@end","text":"新建文件如下 UINavigationController+PushSafe.h 123456#import &lt;UIKit/UIKit.h&gt;@interface UINavigationController(PushSafe)-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated safe:(BOOL)safe;@end UINavigationController+PushSafe.m 123456789101112131415161718192021222324252627282930313233#import \"UINavigationController+PushSafe.h\"@implementation UINavigationController(PushSafe)-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated safe:(BOOL)safe&#123; if ([[self.viewControllers lastObject] isKindOfClass:viewController.class]&amp;&amp;safe) &#123; return ; &#125; [self pushViewController:viewController animated:animated];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/@end 使用方法 1[self.navigationController pushViewController:chatController animated:YES safe:YES];","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"导入JPush后上传到svn上再checkout下来项目报错","slug":"iOS/导入JPush后上传到svn上再checkout下来项目报错","date":"2017-01-11T10:01:22.000Z","updated":"2017-06-15T11:59:31.000Z","comments":true,"path":"2017/01/11/iOS/导入JPush后上传到svn上再checkout下来项目报错/","link":"","permalink":"http://yoursite.com/2017/01/11/iOS/导入JPush后上传到svn上再checkout下来项目报错/","excerpt":"在项目开发中,导入了激光推送的库，结果上传到svn后再checkout下来项目报错了。这是因为svn默认忽略静态库.a文件。解决办法：cornerstone-&gt;Preference","text":"在项目开发中,导入了激光推送的库，结果上传到svn后再checkout下来项目报错了。这是因为svn默认忽略静态库.a文件。解决办法：cornerstone-&gt;Preference 取消打钩 删除.a","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"解决UIWebView显示HTML字符串特殊符号问题","slug":"iOS/解决UIWebView显示HTML字符串特殊符号问题","date":"2017-01-10T14:03:33.000Z","updated":"2017-06-15T12:05:10.000Z","comments":true,"path":"2017/01/10/iOS/解决UIWebView显示HTML字符串特殊符号问题/","link":"","permalink":"http://yoursite.com/2017/01/10/iOS/解决UIWebView显示HTML字符串特殊符号问题/","excerpt":"做项目时后台传入的HTML字符串本来是 &lt;p&gt;&lt;strong&gt;balabalaba&lt;/p&gt;&lt;/strong&gt; 结果被转码成了 &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;balabalaba&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt; 加载到webView显示会有问题，解决办法:","text":"做项目时后台传入的HTML字符串本来是 &lt;p&gt;&lt;strong&gt;balabalaba&lt;/p&gt;&lt;/strong&gt; 结果被转码成了 &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;balabalaba&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt; 加载到webView显示会有问题，解决办法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697- (NSString *)stringByDecodingXMLEntities &#123; NSUInteger myLength = [self length]; NSUInteger ampIndex = [self rangeOfString:@\"&amp;\" options:NSLiteralSearch].location; // Short-circuit if there are no ampersands. if (ampIndex == NSNotFound) &#123; return self; &#125; // Make result string with some extra capacity. NSMutableString *result = [NSMutableString stringWithCapacity:(myLength * 1.25)]; // First iteration doesn't need to scan to &amp; since we did that already, but for code simplicity's sake we'll do it again with the scanner. NSScanner *scanner = [NSScanner scannerWithString:self]; [scanner setCharactersToBeSkipped:nil]; NSCharacterSet *boundaryCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@\" \\t\\n\\r;\"]; do &#123; // Scan up to the next entity or the end of the string. NSString *nonEntityString; if ([scanner scanUpToString:@\"&amp;\" intoString:&amp;nonEntityString]) &#123; [result appendString:nonEntityString]; &#125; if ([scanner isAtEnd]) &#123; goto finish; &#125; // Scan either a HTML or numeric character entity reference. if ([scanner scanString:@\"&amp;\" intoString:NULL]) [result appendString:@\"&amp;\"]; else if ([scanner scanString:@\"'\" intoString:NULL]) [result appendString:@\"'\"]; else if ([scanner scanString:@\"\"\" intoString:NULL]) [result appendString:@\"\\\"\"]; else if ([scanner scanString:@\"&lt;\" intoString:NULL]) [result appendString:@\"&lt;\"]; else if ([scanner scanString:@\"&gt;\" intoString:NULL]) [result appendString:@\"&gt;\"]; else if ([scanner scanString:@\"&amp;#\" intoString:NULL]) &#123; BOOL gotNumber; unsigned charCode; NSString *xForHex = @\"\"; // Is it hex or decimal? if ([scanner scanString:@\"x\" intoString:&amp;xForHex]) &#123; gotNumber = [scanner scanHexInt:&amp;charCode]; &#125; else &#123; gotNumber = [scanner scanInt:(int*)&amp;charCode]; &#125; if (gotNumber) &#123; [result appendFormat:@\"%C\", charCode]; [scanner scanString:@\";\" intoString:NULL]; &#125; else &#123; NSString *unknownEntity = @\"\"; [scanner scanUpToCharactersFromSet:boundaryCharacterSet intoString:&amp;unknownEntity]; [result appendFormat:@\"&amp;#%@%@\", xForHex, unknownEntity]; //[scanner scanUpToString:@\";\" intoString:&amp;unknownEntity]; //[result appendFormat:@\"&amp;#%@%@;\", xForHex, unknownEntity]; NSLog(@\"Expected numeric character entity but got &amp;#%@%@;\", xForHex, unknownEntity); &#125; &#125; else &#123; NSString *amp; [scanner scanString:@\"&amp;\" intoString:&amp;amp]; //an isolated &amp; symbol [result appendString:amp]; /* NSString *unknownEntity = @\"\"; [scanner scanUpToString:@\";\" intoString:&amp;unknownEntity]; NSString *semicolon = @\"\"; [scanner scanString:@\";\" intoString:&amp;semicolon]; [result appendFormat:@\"%@%@\", unknownEntity, semicolon]; NSLog(@\"Unsupported XML character entity %@%@\", unknownEntity, semicolon); */ &#125; &#125; while (![scanner isAtEnd]); finish: return result;&#125;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"SDWebImage更新图片缓存的方法","slug":"iOS/SDWebImage更新图片缓存的方法","date":"2016-11-20T03:26:00.000Z","updated":"2017-06-15T12:06:46.000Z","comments":true,"path":"2016/11/20/iOS/SDWebImage更新图片缓存的方法/","link":"","permalink":"http://yoursite.com/2016/11/20/iOS/SDWebImage更新图片缓存的方法/","excerpt":"","text":"##SDWebImage加载图片，在图片链接相同但图片内容发生变更时，SDWebImage 并不会加载新的图片。此时的解决方案为设置SDWebImage 的option参数为SDWebImageRefreshCached。具体如下图：","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Swift怎么通过类名字符串来创建一个类","slug":"iOS/Swift怎么通过类名字符串来创建一个类","date":"2016-09-20T03:26:00.000Z","updated":"2017-06-15T12:06:56.000Z","comments":true,"path":"2016/09/20/iOS/Swift怎么通过类名字符串来创建一个类/","link":"","permalink":"http://yoursite.com/2016/09/20/iOS/Swift怎么通过类名字符串来创建一个类/","excerpt":"","text":"OC中可以直接通过类名的字符串转换成对应的类来操作,但是Swift中必须用到命名空间,也就是说Swift中通过字符串获取类的方式为1234567891011let namespace = NSBundle.mainBundle().infoDictionary![\"CFBundleExecutable\"]guard ((namespace as? String) != nil) else&#123;return &#125;let modelClass : AnyClass? = NSClassFromString((namespace as? String)!+\".\"+modelClassStr)let baseModel = modelClass?.alloc()","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]