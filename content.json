{"meta":{"title":"浮浮沉沉丶","subtitle":null,"description":null,"author":"浮浮沉沉丶","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2017-03-16T09:44:00.000Z","updated":"2017-03-29T14:34:04.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-03-16T10:40:31.000Z","updated":"2017-03-29T14:33:46.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"天行健，君子以自强不息；地势坤，君子以厚德载物。"},{"title":"标签","date":"2017-03-16T09:45:57.000Z","updated":"2017-03-29T14:34:18.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"UITableView长按拖动排序（支持不同行高间交换）","slug":"iOS/UITableView长按拖动排序（支持不同行高间交换）","date":"2017-06-08T16:00:00.000Z","updated":"2017-06-09T16:28:14.000Z","comments":true,"path":"2017/06/09/iOS/UITableView长按拖动排序（支持不同行高间交换）/","link":"","permalink":"http://yoursite.com/2017/06/09/iOS/UITableView长按拖动排序（支持不同行高间交换）/","excerpt":"","text":"效果图： github下载地址：DHDragableCellTableView 使用将tableView继承与DHDragableCellTableView并遵循协议DHDragableCellTableViewDataSource,DHDragableCellTableViewDelegate 123456789#pragma mark - DHDragableCellTableViewDataSource- (NSArray *)dataSourceArrayInTableView:(DHDragableCellTableView *)tableView&#123; return self.dataSource.copy;//数据源&#125;- (void)tableView:(DHDragableCellTableView *)tableView newDataSourceArrayAfterMove:(NSArray *)newDataSourceArray&#123; self.dataSource = newDataSourceArray.mutableCopy;//返回的数据源 [self.tableView reloadData];&#125; 实现：大概思路，为UITableView添加长按手势，长按后给选择的cell截图并隐藏选择的cell,让截图跟随手势移动 添加手势 123456789/** 添加手势 */- (void)dh_addGesture&#123; _gesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(dh_processGesture:)]; _gesture.minimumPressDuration = _gestureMinimumPressDuration; [self addGestureRecognizer:_gesture];&#125; 监听手势状态 12345678910111213141516171819202122232425- (void)dh_processGesture:(UILongPressGestureRecognizer *)gesture&#123; switch (gesture.state) &#123; case UIGestureRecognizerStateBegan: &#123; [self dh_gestureBegan:gesture]; &#125; break; case UIGestureRecognizerStateChanged: &#123; if (!_canEdgeScroll) &#123; [self dh_gestureChanged:gesture]; &#125; &#125; break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: &#123; [self dh_gestureEndedOrCancelled:gesture]; &#125; break; default: break; &#125;&#125; 开始拖动 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)dh_gestureBegan:(UILongPressGestureRecognizer *)gesture&#123; CGPoint point = [gesture locationInView:gesture.view]; self.lastPoint = point; NSIndexPath *selectedIndexPath = [self indexPathForRowAtPoint:point]; if (!selectedIndexPath) &#123; return; &#125; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(tableView:willMoveCellAtIndexPath:)]) &#123; [self.delegate tableView:self willMoveCellAtIndexPath:selectedIndexPath]; &#125; if (_canEdgeScroll) &#123; //开启边缘滚动 [self dh_startEdgeScroll]; &#125; //每次移动开始获取一次数据源 if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(dataSourceArrayInTableView:)]) &#123; _tempDataSource = [self.dataSource dataSourceArrayInTableView:self].mutableCopy; &#125; _selectedIndexPath = selectedIndexPath; UITableViewCell *cell = [self cellForRowAtIndexPath:selectedIndexPath]; _tempView = [self dh_snapshotViewWithInputView:cell]; if (_drawMovalbeCellBlock) &#123; //将_tempView通过block让使用者自定义 _drawMovalbeCellBlock(_tempView); &#125;else &#123; //配置默认样式 _tempView.layer.shadowColor = [UIColor grayColor].CGColor; _tempView.layer.masksToBounds = NO; _tempView.layer.cornerRadius = 0; _tempView.layer.shadowOffset = CGSizeMake(-5, 0); _tempView.layer.shadowOpacity = 0.4; _tempView.layer.shadowRadius = 5; &#125; _tempView.frame = cell.frame; [self addSubview:_tempView]; //隐藏cell cell.hidden = YES; [UIView animateWithDuration:kDH_DragableCellAnimationTime animations:^&#123; _tempView.center = CGPointMake(_tempView.center.x, point.y); &#125;];&#125; 拖动 这里的_toBottom是int类型用来判断手势是向哪一个方向拖动，然后根据拖动的cell跟要交换的cell的中心点进行比较，判断是否交换 1234567891011121314151617181920212223242526272829- (void)dh_gestureChanged:(UILongPressGestureRecognizer *)gesture&#123; CGPoint point = [gesture locationInView:gesture.view]; //判断拖动的方向 if (point.y - self.lastPoint.y &gt; 0) &#123; _toBottom = 1;//向下拖 &#125;else if(point.y - self.lastPoint.y &lt; 0)&#123; _toBottom = -1;//向上拖 &#125;else&#123; _toBottom = 0; &#125; self.lastPoint = point; NSIndexPath *currentIndexPath = [self indexPathForRowAtPoint:point]; if (currentIndexPath &amp;&amp; ![_selectedIndexPath isEqual:currentIndexPath]) &#123; UITableViewCell *cell = [self cellForRowAtIndexPath:_selectedIndexPath]; UITableViewCell *cell1 = [self cellForRowAtIndexPath:currentIndexPath]; //将拖动的cell跟要交换的cell的centerY进行比较 if ((_toBottom == 1 &amp;&amp; (point.y+cell.frame.size.height/2) &gt;= CGRectGetMaxY(cell1.frame) &amp;&amp; (CGRectGetMaxY(cell1.frame) &gt;= CGRectGetMaxY(cell.frame))) || ((_toBottom == -1 &amp;&amp; (point.y-cell.frame.size.height/2) &lt;= CGRectGetMinY(cell1.frame)) &amp;&amp; (CGRectGetMinY(cell1.frame) &lt;= CGRectGetMinY(cell.frame)))) &#123; //交换数据源和cell [self dh_updateDataSourceAndCellFromIndexPath:_selectedIndexPath toIndexPath:currentIndexPath]; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(tableView:didMoveCellFromIndexPath:toIndexPath:)]) &#123; [self.delegate tableView:self didMoveCellFromIndexPath:_selectedIndexPath toIndexPath:currentIndexPath]; &#125; _selectedIndexPath = currentIndexPath; &#125; &#125; //让截图跟随手势 _tempView.center = CGPointMake(_tempView.center.x, point.y);&#125; 交换数据跟cell的位置 为了在不同行高交换时cell不变形，交换后要立刻reloadData，再通过对两个cell截图，用截图来模拟交换的动画 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** 交换数据源 跟 cell的位置 */- (void)dh_updateDataSourceAndCellFromIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath&#123; if ([self numberOfSections] == 1) &#123; //只有一组 [_tempDataSource exchangeObjectAtIndex:fromIndexPath.row withObjectAtIndex:toIndexPath.row]; //交换cell [self moveRowAtIndexPath:fromIndexPath toIndexPath:toIndexPath]; &#125;else &#123; //有多组 id fromData = _tempDataSource[fromIndexPath.section][fromIndexPath.row]; id toData = _tempDataSource[toIndexPath.section][toIndexPath.row]; NSMutableArray *fromArray = [_tempDataSource[fromIndexPath.section] mutableCopy]; NSMutableArray *toArray = [_tempDataSource[toIndexPath.section] mutableCopy]; [fromArray replaceObjectAtIndex:fromIndexPath.row withObject:toData]; [toArray replaceObjectAtIndex:toIndexPath.row withObject:fromData]; [_tempDataSource replaceObjectAtIndex:fromIndexPath.section withObject:fromArray]; [_tempDataSource replaceObjectAtIndex:toIndexPath.section withObject:toArray]; //交换cell [self beginUpdates]; [self moveRowAtIndexPath:fromIndexPath toIndexPath:toIndexPath]; [self moveRowAtIndexPath:toIndexPath toIndexPath:fromIndexPath]; [self endUpdates]; &#125; //交换数据源后reloadData [self reloadData]; //返回交换后的数据源 if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(tableView:newDataSourceArrayAfterMove:)]) &#123; [self.dataSource tableView:self newDataSourceArrayAfterMove:_tempDataSource.copy]; &#125; //此处用两个cell的截图实现交换的动画 UITableViewCell *cell = [self cellForRowAtIndexPath:fromIndexPath]; cell.hidden = NO; UITableViewCell *cell1 = [self cellForRowAtIndexPath:toIndexPath]; cell1.hidden = YES; UIView *tmpCell = [self dh_snapshotViewWithInputView:cell]; cell.hidden = YES; tmpCell.frame = cell1.frame; if (_toBottom == -1) &#123;//向上 tmpCell.frame = CGRectMake(0, CGRectGetMinY(cell1.frame), cell.frame.size.width, cell.frame.size.height); [self insertSubview:tmpCell belowSubview:_tempView]; &#125;else if (_toBottom == 1) &#123;//向下 tmpCell.frame = CGRectMake(0, CGRectGetMaxY(cell1.frame)-cell.frame.size.height, cell.frame.size.width, cell.frame.size.height); [self insertSubview:tmpCell belowSubview:_tempView]; &#125;else&#123; &#125; [UIView animateWithDuration:0.2 animations:^&#123; tmpCell.frame = cell.frame; &#125;completion:^(BOOL finished) &#123; cell.hidden = NO; [tmpCell removeFromSuperview]; &#125;];&#125; 边缘滚动处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)dh_startEdgeScroll&#123; _edgeScrollTimer = [CADisplayLink displayLinkWithTarget:self selector:@selector(dh_processEdgeScroll)]; [_edgeScrollTimer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)dh_processEdgeScroll&#123; [self dh_gestureChanged:_gesture]; CGFloat minOffsetY = self.contentOffset.y + _edgeScrollRange; CGFloat maxOffsetY = self.contentOffset.y + self.bounds.size.height - _edgeScrollRange; CGPoint touchPoint = _tempView.center; //处理上下达到极限之后不再滚动tableView，其中处理了滚动到最边缘的时候，当前处于edgeScrollRange内，但是tableView还未显示完，需要显示完tableView才停止滚动 if (touchPoint.y &lt; _edgeScrollRange) &#123; if (self.contentOffset.y &lt;= 0) &#123; return; &#125;else &#123; if (self.contentOffset.y - 1 &lt; 0) &#123; return; &#125; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y - 1) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y - 1); &#125; &#125; if (touchPoint.y &gt; self.contentSize.height - _edgeScrollRange) &#123; if (self.contentOffset.y &gt;= self.contentSize.height - self.bounds.size.height) &#123; return; &#125;else &#123; if (self.contentOffset.y + 1 &gt; self.contentSize.height - self.bounds.size.height) &#123; return; &#125; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y + 1) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y + 1); &#125; &#125; //处理滚动 CGFloat maxMoveDistance = 20; if (touchPoint.y &lt; minOffsetY) &#123; //cell在往上移动 CGFloat moveDistance = (minOffsetY - touchPoint.y)/_edgeScrollRange*maxMoveDistance; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y - moveDistance) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y - moveDistance); &#125;else if (touchPoint.y &gt; maxOffsetY) &#123; //cell在往下移动 CGFloat moveDistance = (touchPoint.y - maxOffsetY)/_edgeScrollRange*maxMoveDistance; [self setContentOffset:CGPointMake(self.contentOffset.x, self.contentOffset.y + moveDistance) animated:NO]; _tempView.center = CGPointMake(_tempView.center.x, _tempView.center.y + moveDistance); &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS开发输入框字数限制","slug":"iOS/iOS开发输入框字数限制","date":"2017-05-22T16:00:00.000Z","updated":"2017-05-23T02:12:14.000Z","comments":true,"path":"2017/05/23/iOS/iOS开发输入框字数限制/","link":"","permalink":"http://yoursite.com/2017/05/23/iOS/iOS开发输入框字数限制/","excerpt":"","text":"在在网上查了资料，\u0010很多都是下面这个方法，但是在原生键盘上是有问题的，当当在手机上英文九宫格连点的时候，会替换掉最后的文字 123456789101112131415161718192021222324252627282930313233343536373839404142[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(textFieldEditChanged:) name:@&quot;UITextFieldTextDidChangeNotification&quot; object:myTextField];-(void)textFieldEditChanged:(NSNotification *)obj&#123; UITextField *textField = (UITextField *)obj.object; NSString *toBeString = textField.text; NSString *lang = [textField.textInputMode primaryLanguage]; if ([lang isEqualToString:@&quot;zh-Hans&quot;])// 简体中文输入 &#123; //获取高亮部分 UITextRange *selectedRange = [textField markedTextRange]; UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0]; // 没有高亮选择的字，则对已输入的文字进行字数统计和限制 if (!position) &#123; if (toBeString.length &gt; MAX_STARWORDS_LENGTH) &#123; textField.text = [toBeString substringToIndex:MAX_STARWORDS_LENGTH]; &#125; &#125; &#125; // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况 else &#123; if (toBeString.length &gt; MAX_STARWORDS_LENGTH) &#123; NSRange rangeIndex = [toBeString rangeOfComposedCharacterSequenceAtIndex:MAX_STARWORDS_LENGTH]; if (rangeIndex.length == 1) &#123; textField.text = [toBeString substringToIndex:MAX_STARWORDS_LENGTH]; &#125; else &#123; NSRange rangeRange = [toBeString rangeOfComposedCharacterSequencesForRange:NSMakeRange(0, MAX_STARWORDS_LENGTH)]; textField.text = [toBeString substringWithRange:rangeRange]; &#125; &#125; &#125;&#125; 经过多次测试后，终于解决了，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static const int nameMaxLength = 6;@interface FCEditNameViewController ()&lt;UITextFieldDelegate&gt;@property (strong, nonatomic) IBOutlet UITextField *nameTextField;@property (nonatomic, strong) NSString *oldStr;//记录修改之前的值@property (nonatomic, strong) NSString *positionStr;记录高亮的文字@end//当前光标位置 range.location //已选文字长度 range.length - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; if ([string isEqualToString:@&quot;&quot;]) &#123; return YES; &#125; //获取高亮部分 UITextRange *selectedRange = [textField markedTextRange]; UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0]; if (!position) &#123; self.oldStr = textField.text; if (range.length + range.location &gt; textField.text.length) &#123; return NO; &#125; NSInteger newStrLength = [textField.text length] + [string length] - range.length; if (newStrLength &lt;= nameMaxLength) &#123; return YES; &#125;else&#123; return NO; &#125; &#125;else&#123; if ([self IsChinese:string]) &#123; NSString *str = [NSString stringWithFormat:@&quot;%@%@&quot;,self.oldStr,string]; self.oldStr = @&quot;&quot;; if (str.length &gt; nameMaxLength) &#123; return NO; &#125;else&#123; return YES; &#125; &#125; &#125; return YES;&#125;//判断是否有中文- (BOOL)IsChinese:(NSString *)str &#123; for(int i=0; i&lt; [str length];i++)&#123; int a = [str characterAtIndex:i]; if( a &gt; 0x4e00 &amp;&amp; a &lt; 0x9fff) &#123; return YES; &#125; &#125; return NO;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Xcode打断点调试时所有的变量都为nil","slug":"iOS/Xcode打断点调试时所有的变量都为nil","date":"2017-05-19T16:00:00.000Z","updated":"2017-05-25T15:13:25.000Z","comments":true,"path":"2017/05/20/iOS/Xcode打断点调试时所有的变量都为nil/","link":"","permalink":"http://yoursite.com/2017/05/20/iOS/Xcode打断点调试时所有的变量都为nil/","excerpt":"","text":"今天开发的\u0010时候打断点进行调试，结果控制台上显示的变量都是nil,例: ![http://upload-images.jianshu.io/upload_images/1353091-216e812b0cbd7271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 解决办法，如图： ![http://upload-images.jianshu.io/upload_images/1353091-fa995633fc3a43ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 将Optimization Level 设为none","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"AFNetworking的requestSerializer跟responseSerializer","slug":"iOS/AFNetworking的requestSerializer跟responseSerializer","date":"2017-05-15T16:00:00.000Z","updated":"2017-05-16T13:33:50.000Z","comments":true,"path":"2017/05/16/iOS/AFNetworking的requestSerializer跟responseSerializer/","link":"","permalink":"http://yoursite.com/2017/05/16/iOS/AFNetworking的requestSerializer跟responseSerializer/","excerpt":"","text":"requestSerializerrequestSerializer它是AFNetworking参数编码的序列化器： AFHTTPRequestSerializer普通的http的编码格式，二进制 AFJSONRequestSerializerjson编码格式 AFPropertyListRequestSerializerplist编码格式 responseSerializerresponseSerializer它是AFNetworking返回内容编码的序列化器： AFHTTPResponseSerializer普通的http的编码格式，二进制 AFJSONResponseSerializer json编码格式 AFXMLParserRequestSerializer plist编码格式 AFXMLDocumentResponseSerializer XML,只能返回XMLParser，还需要自己解析 AFPropertyListRequestSerializer plist编码格式 AFImageResponseSerializer image AFCompoundRequestSerializer 组合","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"jQuery的使用","slug":"web/jQuery的使用","date":"2017-04-25T16:00:00.000Z","updated":"2017-04-26T07:46:26.000Z","comments":true,"path":"2017/04/26/web/jQuery的使用/","link":"","permalink":"http://yoursite.com/2017/04/26/web/jQuery的使用/","excerpt":"","text":"jQuery DOM操作 jQuery 获取123456$(\"#btn1\").click(function()&#123; alert(\"Text: \" + $(\"#test\").text());&#125;);$(\"#btn2\").click(function()&#123; alert(\"HTML: \" + $(\"#test\").html());&#125;); 亲自试一试 jQuery 设置123456789$(\"#btn1\").click(function()&#123; $(\"#test1\").text(\"Hello world!\");&#125;);$(\"#btn2\").click(function()&#123; $(\"#test2\").html(\"&lt;b&gt;Hello world!&lt;/b&gt;\");&#125;);$(\"#btn3\").click(function()&#123; $(\"#test3\").val(\"Dolly Duck\");&#125;); 亲自试一试 jQuery 添加 append() - 在被选元素内的结尾插入内容 1$(\"p\").append(\"Some appended text.\"); 亲自试一试 prepend() - 在被选元素内的开头插入内容 1$(\"p\").prepend(\"Some prepended text.\"); 亲自试一试 after() - 在被选元素之后插入内容 1$(\"img\").after(\"Some text after\"); 亲自试一试 before() - 在被选元素之前插入内容 1$(\"img\").before(\"Some text before\"); 亲自试一试 jQuery 删除 remove() - 删除被选元素（及其子元素） 1$(\"#div1\").remove(); 亲自试一试 empty() - 从被选元素中删除子元素 1$(\"#div1\").empty(); 亲自试一试 jQuery css()设置css属性 1$(\"p\").css(\"background-color\"); 亲自试一试 设置多个css属性 1$(\"p\").css(&#123;\"background-color\":\"yellow\",\"font-size\":\"200%\"&#125;); 亲自试一试 jQuery 效果 jQuery 隐藏/显示1234567$(\"#hide\").click(function()&#123; $(\"p\").hide();&#125;);$(\"#show\").click(function()&#123; $(\"p\").show();&#125;); 亲自试一试 jQuery 淡入淡出 fadeIn() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeIn(); $(\"#div2\").fadeIn(\"slow\"); $(\"#div3\").fadeIn(3000);&#125;); 亲自试一试 fadeOut() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeOut(); $(\"#div2\").fadeOut(\"slow\"); $(\"#div3\").fadeOut(3000);&#125;); 亲自试一试 fadeToggle() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeToggle(); $(\"#div2\").fadeToggle(\"slow\"); $(\"#div3\").fadeToggle(3000);&#125;); 亲自试一试 fadeTo() 12345$(\"button\").click(function()&#123; $(\"#div1\").fadeTo(\"slow\",0.15); $(\"#div2\").fadeTo(\"slow\",0.4); $(\"#div3\").fadeTo(\"slow\",0.7);&#125;); 亲自试一试 jQuery 滑动 slideDown() slideUp() slideToggle() ​ ​","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"hexo主题代码怎么高亮显示","slug":"other/hexo主题代码怎么高亮显示","date":"2017-03-06T16:00:00.000Z","updated":"2017-03-28T13:21:59.000Z","comments":true,"path":"2017/03/07/other/hexo主题代码怎么高亮显示/","link":"","permalink":"http://yoursite.com/2017/03/07/other/hexo主题代码怎么高亮显示/","excerpt":"","text":"看到很多人跟我一样在按照hexo主题官方文档配置后，结果代码还是不能高亮显示。觉得将它记录下来希望能帮助到刚喜欢用博客来记录东西的朋友。 代码块需要用到两个```,在第一个后面需要加上代码的语言 如图 常用语言对应表 语言 对应代码 Bash bash,sh,zsh C# cs,csharp C++ cpp,c,cc,h,c++,h++,hop CSS css DOS dos,bat,cmd HTML,XML xml,html,xhtml,rss,atom,xjb,xsd,ssl,plist JSON json java java JavaScript javascript, js, jsx Objective-C objectivec, mm, objc, obj-c PHP php, php3, php4, php5, php6 Ruby ruby, rb, gemspec, podspec, thor, irb SQL sql Swift swift VB.Net vbnet, vb","categories":[{"name":"other","slug":"other","permalink":"http://yoursite.com/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]},{"title":"DOM对象与jquery对象有什么不同","slug":"web/DOM对象与jquery对象有什么不同","date":"2017-03-04T16:00:00.000Z","updated":"2017-03-29T06:20:33.000Z","comments":true,"path":"2017/03/05/web/DOM对象与jquery对象有什么不同/","link":"","permalink":"http://yoursite.com/2017/03/05/web/DOM对象与jquery对象有什么不同/","excerpt":"","text":"jQuery对象和DOM对象第一次学习jQuery,经常分辨不清哪些是jQuery对象，哪些是 DOM对象，因此需要重点了解jQuery对象和DOM对象以及它们之间的关系. DOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象; 1var domObj = document.getElementById(\"id\"); //DOM对象 1var $obj = $(\"#id\"); //jQuery对象; jQuery对象就是通过jQuery包装DOM对象后产生的对象，它是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法，例: 1$(\"#foo\").html(); //获取id为foo的元素内的html代码，html()是jQuery特有的方法; 上面的那段代码等同于: 1document.getElementById(\"foo\").innerHTML; 注意：在jQuery对象中无法使用DOM对象的任何方法。 例如$(&quot;#id&quot;).innerHTML和$(&quot;#id&quot;).checked之类的写法都是错误的，可以用$(&quot;#id&quot;).html()和$(&quot;#id&quot;).attr (&quot;checked&quot;)之类的jQuery方法来代替。同样，DOM对象也不能使用jQuery方法。 jQuery对象和DOM对象的互相转换jquery对象转换成 dom对象jquery提供了两种方法将一个jquery对象转换成一个dom对象，即[index]和get(index)。可能有人会觉得奇怪，怎么是用下标呢，没错，jquery对象就是一个数组对象. 下面代码将演示一个jquery对象转换成dom对象，再使用dom对象的方法 1var $cr=$(\"#cr\"); //jquery对象 1var cr = $cr[0]; //dom对象 也可写成 var cr=$cr.get(0); 1alert(cr.checked); //检测这个checkbox是否给选中 dom对象转换成jquery对象对于一个dom对象，只需要用$()把dom对象包装起来，就可以获得一个jquery对象了，方法为$(dom对象); 1var cr=document.getElementById(\"cr\"); //dom对象 1var $cr = $(cr); //转换成jquery对象 转换后可以任意使用jquery中的方法了. 通过以上的方法，可以任意的相互转换jquery对象和dom对象.","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"一行代码解决NavigationController多次push问题","slug":"iOS/一行代码解决NavigationController多次push问题","date":"2017-01-20T03:26:00.000Z","updated":"2017-03-28T10:23:22.000Z","comments":true,"path":"2017/01/20/iOS/一行代码解决NavigationController多次push问题/","link":"","permalink":"http://yoursite.com/2017/01/20/iOS/一行代码解决NavigationController多次push问题/","excerpt":"","text":"新建文件如下 UINavigationController+PushSafe.h 123456#import &lt;UIKit/UIKit.h&gt;@interface UINavigationController(PushSafe)-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated safe:(BOOL)safe;@end UINavigationController+PushSafe.m 123456789101112131415161718192021222324252627282930313233#import \"UINavigationController+PushSafe.h\"@implementation UINavigationController(PushSafe)-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated safe:(BOOL)safe&#123; if ([[self.viewControllers lastObject] isKindOfClass:viewController.class]&amp;&amp;safe) &#123; return ; &#125; [self pushViewController:viewController animated:animated];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/@end 使用方法 1[self.navigationController pushViewController:chatController animated:YES safe:YES];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"导入JPush后上传到svn上再checkout下来项目报错","slug":"iOS/导入JPush后上传到svn上再checkout下来项目报错","date":"2017-01-11T10:01:22.000Z","updated":"2017-03-29T14:21:44.000Z","comments":true,"path":"2017/01/11/iOS/导入JPush后上传到svn上再checkout下来项目报错/","link":"","permalink":"http://yoursite.com/2017/01/11/iOS/导入JPush后上传到svn上再checkout下来项目报错/","excerpt":"","text":"在项目开发中,导入了激光推送的库，结果上传到svn后再checkout下来项目报错了。这是因为svn默认忽略静态库.a文件。解决办法：cornerstone-&gt;Preference 取消打钩 删除.a","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"解决UIWebView显示HTML字符串特殊符号问题","slug":"iOS/解决UIWebView显示HTML字符串特殊符号问题","date":"2017-01-10T14:03:33.000Z","updated":"2017-03-29T06:17:58.000Z","comments":true,"path":"2017/01/10/iOS/解决UIWebView显示HTML字符串特殊符号问题/","link":"","permalink":"http://yoursite.com/2017/01/10/iOS/解决UIWebView显示HTML字符串特殊符号问题/","excerpt":"","text":"做项目时后台传入的HTML字符串本来是 &lt;p&gt;&lt;strong&gt;balabalaba&lt;/p&gt;&lt;/strong&gt; 结果被转码成了 &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;balabalaba&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt; 加载到webView显示会有问题，解决办法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697- (NSString *)stringByDecodingXMLEntities &#123; NSUInteger myLength = [self length]; NSUInteger ampIndex = [self rangeOfString:@\"&amp;\" options:NSLiteralSearch].location; // Short-circuit if there are no ampersands. if (ampIndex == NSNotFound) &#123; return self; &#125; // Make result string with some extra capacity. NSMutableString *result = [NSMutableString stringWithCapacity:(myLength * 1.25)]; // First iteration doesn't need to scan to &amp; since we did that already, but for code simplicity's sake we'll do it again with the scanner. NSScanner *scanner = [NSScanner scannerWithString:self]; [scanner setCharactersToBeSkipped:nil]; NSCharacterSet *boundaryCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@\" \\t\\n\\r;\"]; do &#123; // Scan up to the next entity or the end of the string. NSString *nonEntityString; if ([scanner scanUpToString:@\"&amp;\" intoString:&amp;nonEntityString]) &#123; [result appendString:nonEntityString]; &#125; if ([scanner isAtEnd]) &#123; goto finish; &#125; // Scan either a HTML or numeric character entity reference. if ([scanner scanString:@\"&amp;\" intoString:NULL]) [result appendString:@\"&amp;\"]; else if ([scanner scanString:@\"'\" intoString:NULL]) [result appendString:@\"'\"]; else if ([scanner scanString:@\"\"\" intoString:NULL]) [result appendString:@\"\\\"\"]; else if ([scanner scanString:@\"&lt;\" intoString:NULL]) [result appendString:@\"&lt;\"]; else if ([scanner scanString:@\"&gt;\" intoString:NULL]) [result appendString:@\"&gt;\"]; else if ([scanner scanString:@\"&amp;#\" intoString:NULL]) &#123; BOOL gotNumber; unsigned charCode; NSString *xForHex = @\"\"; // Is it hex or decimal? if ([scanner scanString:@\"x\" intoString:&amp;xForHex]) &#123; gotNumber = [scanner scanHexInt:&amp;charCode]; &#125; else &#123; gotNumber = [scanner scanInt:(int*)&amp;charCode]; &#125; if (gotNumber) &#123; [result appendFormat:@\"%C\", charCode]; [scanner scanString:@\";\" intoString:NULL]; &#125; else &#123; NSString *unknownEntity = @\"\"; [scanner scanUpToCharactersFromSet:boundaryCharacterSet intoString:&amp;unknownEntity]; [result appendFormat:@\"&amp;#%@%@\", xForHex, unknownEntity]; //[scanner scanUpToString:@\";\" intoString:&amp;unknownEntity]; //[result appendFormat:@\"&amp;#%@%@;\", xForHex, unknownEntity]; NSLog(@\"Expected numeric character entity but got &amp;#%@%@;\", xForHex, unknownEntity); &#125; &#125; else &#123; NSString *amp; [scanner scanString:@\"&amp;\" intoString:&amp;amp]; //an isolated &amp; symbol [result appendString:amp]; /* NSString *unknownEntity = @\"\"; [scanner scanUpToString:@\";\" intoString:&amp;unknownEntity]; NSString *semicolon = @\"\"; [scanner scanString:@\";\" intoString:&amp;semicolon]; [result appendFormat:@\"%@%@\", unknownEntity, semicolon]; NSLog(@\"Unsupported XML character entity %@%@\", unknownEntity, semicolon); */ &#125; &#125; while (![scanner isAtEnd]); finish: return result;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"SDWebImage更新图片缓存的方法","slug":"iOS/SDWebImage更新图片缓存的方法","date":"2016-11-20T03:26:00.000Z","updated":"2017-03-24T02:25:28.000Z","comments":true,"path":"2016/11/20/iOS/SDWebImage更新图片缓存的方法/","link":"","permalink":"http://yoursite.com/2016/11/20/iOS/SDWebImage更新图片缓存的方法/","excerpt":"","text":"##SDWebImage加载图片，在图片链接相同但图片内容发生变更时，SDWebImage 并不会加载新的图片。此时的解决方案为设置SDWebImage 的option参数为SDWebImageRefreshCached。具体如下图：","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Swift怎么通过类名字符串来创建一个类","slug":"iOS/Swift怎么通过类名字符串来创建一个类","date":"2016-09-20T03:26:00.000Z","updated":"2017-03-29T06:19:10.000Z","comments":true,"path":"2016/09/20/iOS/Swift怎么通过类名字符串来创建一个类/","link":"","permalink":"http://yoursite.com/2016/09/20/iOS/Swift怎么通过类名字符串来创建一个类/","excerpt":"","text":"OC中可以直接通过类名的字符串转换成对应的类来操作,但是Swift中必须用到命名空间,也就是说Swift中通过字符串获取类的方式为1234567891011let namespace = NSBundle.mainBundle().infoDictionary![\"CFBundleExecutable\"]guard ((namespace as? String) != nil) else&#123;return &#125;let modelClass : AnyClass? = NSClassFromString((namespace as? String)!+\".\"+modelClassStr)let baseModel = modelClass?.alloc()","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}