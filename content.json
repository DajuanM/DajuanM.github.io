{"meta":{"title":"浮浮沉沉丶","subtitle":null,"description":null,"author":"浮浮沉沉丶","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2017-03-16T09:44:00.000Z","updated":"2017-03-16T14:47:14.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-03-16T09:45:57.000Z","updated":"2017-03-22T14:11:47.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-03-16T10:40:31.000Z","updated":"2017-03-24T03:11:06.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"天行健，君子以自强不息；地势坤，君子以厚德载物。"}],"posts":[{"title":"DOM对象与jquery对象有什么不同","slug":"iOS/DOM对象与jquery对象有什么不同","date":"2017-03-04T16:00:00.000Z","updated":"2017-03-28T09:53:44.000Z","comments":true,"path":"2017/03/05/iOS/DOM对象与jquery对象有什么不同/","link":"","permalink":"http://yoursite.com/2017/03/05/iOS/DOM对象与jquery对象有什么不同/","excerpt":"","text":"jQuery对象和DOM对象第一次学习jQuery,经常分辨不清哪些是jQuery对象，哪些是 DOM对象，因此需要重点了解jQuery对象和DOM对象以及它们之间的关系. DOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象; 1var domObj = document.getElementById(&quot;id&quot;); //DOM对象 1var $obj = $(&quot;#id&quot;); //jQuery对象; jQuery对象就是通过jQuery包装DOM对象后产生的对象，它是jQuery独有的。如果一个对象是jQuery对象，那么就可以使用jQuery里的方法，例: 1$(&quot;#foo&quot;).html(); //获取id为foo的元素内的html代码，html()是jQuery特有的方法; 上面的那段代码等同于: 1document.getElementById(&quot;foo&quot;).innerHTML; 注意：在jQuery对象中无法使用DOM对象的任何方法。 例如$(&quot;#id&quot;).innerHTML和$(&quot;#id&quot;).checked之类的写法都是错误的，可以用$(&quot;#id&quot;).html()和$(&quot;#id&quot;).attr (&quot;checked&quot;)之类的jQuery方法来代替。同样，DOM对象也不能使用jQuery方法。 jQuery对象和DOM对象的互相转换jquery对象转换成 dom对象jquery提供了两种方法将一个jquery对象转换成一个dom对象，即[index]和get(index)。可能有人会觉得奇怪，怎么是用下标呢，没错，jquery对象就是一个数组对象. 下面代码将演示一个jquery对象转换成dom对象，再使用dom对象的方法 1var $cr=$(&quot;#cr&quot;); //jquery对象 1var cr = $cr[0]; //dom对象 也可写成 var cr=$cr.get(0); 1alert(cr.checked); //检测这个checkbox是否给选中 dom对象转换成jquery对象对于一个dom对象，只需要用$()把dom对象包装起来，就可以获得一个jquery对象了，方法为$(dom对象); 1var cr=document.getElementById(&quot;cr&quot;); //dom对象 1var $cr = $(cr); //转换成jquery对象 转换后可以任意使用jquery中的方法了. 通过以上的方法，可以任意的相互转换jquery对象和dom对象.","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"iOS中内存泄漏调试","slug":"iOS/iOS内存泄漏","date":"2017-02-20T10:01:22.000Z","updated":"2017-03-24T02:55:52.000Z","comments":true,"path":"2017/02/20/iOS/iOS内存泄漏/","link":"","permalink":"http://yoursite.com/2017/02/20/iOS/iOS内存泄漏/","excerpt":"","text":"iOS开发中，内存问题一直是个长久不变的问题。这不，项目间歇间，用xcode自带的Leak跑了一下程序，发现了几个内存泄漏的地方，都是平时自己没有注意到的，并做出相应改正。在这里记录下。 ##1.运行程序 让程序先跑起来 ##2.进入Leak工具 如上图，选中show the debug（箭头指的），然后点击Memory 然后点击profile in instruments,通过Leak重新运行程序(弹出框中选择Restart ##3.操作Leak工具 如上图，此时程序在跑起来了，Leak Checks右边显示绿色的钩，表示当前没有内存泄漏，这时候我们就可以操作我的app了，跑起来吧，直到发现有红色的X，表示在这里有内存泄漏，如下图 点击红色X，选择Call Tree，如下图 这时候下面的列表会出来很多方法，但都是系统的，表示看不懂有木有啊。。。这时候点击右边中间的选项，然后勾选Call Tree下的Separate by Thread 和 Hide System Libraries，如下图 然后再看左右，下面列表的方法就会变成了我们自己写的方法了，如下图 在这里，有的人肯定会有疑问，为啥他的列表里的方法都是一些进制类的看不懂的，或者就是空白，这是因为Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件。显示进制是因为我们的工程build settings 的问题，没有生成dSYM 文件，也就无法解析debug symbols。做法如下图 在Build Options将Debug information Format选择dsYM，这里默认的可能是release下选择的，将debug下也选择就可以了。然后重新从编译，重新运行，从第一步重新走一遍即可出来最后双击列表中暴露出来的方法，会直接显示代码，神不神奇~ 利用这个调试方法，里里外外将我们程序跑一跑，将内存泄漏的地方都改过来，这样程序闪退的机率将会大大减小。 关于product-&gt;analyze分析内存泄漏的问题优点：分析速度快，并且可以对所有的代码进行内存分析缺点：分析结果不一定准确（没有运行程序，根据代码的上下文语法结构）所以最好还是用Leak工具进行动态运行检查。 路漫漫其修远兮，吾将上下而求索，与君互勉。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"一行代码解决NavigationController多次push问题","slug":"iOS/一行代码解决NavigationController多次push问题","date":"2017-01-20T03:26:00.000Z","updated":"2017-03-24T02:24:58.000Z","comments":true,"path":"2017/01/20/iOS/一行代码解决NavigationController多次push问题/","link":"","permalink":"http://yoursite.com/2017/01/20/iOS/一行代码解决NavigationController多次push问题/","excerpt":"","text":"新建文件如下 UINavigationController+PushSafe.h 12345#import &lt;UIKit/UIKit.h&gt;@interface UINavigationController(PushSafe)-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated safe:(BOOL)safe;@end UINavigationController+PushSafe.m 123456789101112131415161718192021222324252627282930313233#import &quot;UINavigationController+PushSafe.h&quot;@implementation UINavigationController(PushSafe)-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated safe:(BOOL)safe&#123; if ([[self.viewControllers lastObject] isKindOfClass:viewController.class]&amp;&amp;safe) &#123; return ; &#125; [self pushViewController:viewController animated:animated];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view.&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/@end 使用方法 1[self.navigationController pushViewController:chatController animated:YES safe:YES];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"导入JPush后上传到svn上再checkout下来项目报错","slug":"iOS/导入JPush后上传到svn上再checkout下来项目报错","date":"2017-01-11T10:01:22.000Z","updated":"2017-03-28T08:16:34.000Z","comments":true,"path":"2017/01/11/iOS/导入JPush后上传到svn上再checkout下来项目报错/","link":"","permalink":"http://yoursite.com/2017/01/11/iOS/导入JPush后上传到svn上再checkout下来项目报错/","excerpt":"","text":"##在项目开发中,导入了激光推送的库，结果上传到svn后再checkout下来项目报错了。这是因为svn默认忽略静态库.a文件。 ##解决办法：cornerstone-&gt;Preference 取消打钩 删除.a","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"解决UIWebView显示HTML字符串特殊符号问题","slug":"iOS/解决UIWebView显示HTML字符串特殊符号问题","date":"2017-01-10T14:03:33.000Z","updated":"2017-03-24T02:25:11.000Z","comments":true,"path":"2017/01/10/iOS/解决UIWebView显示HTML字符串特殊符号问题/","link":"","permalink":"http://yoursite.com/2017/01/10/iOS/解决UIWebView显示HTML字符串特殊符号问题/","excerpt":"","text":"做项目时后台传入的HTML字符串本来是 &lt;p&gt;&lt;strong&gt;balabalaba&lt;/p&gt;&lt;/strong&gt; 结果被转码成了 &amp;lt;p&amp;gt;&amp;lt;strong&amp;gt;balabalaba&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt; 加载到webView显示会有问题，解决办法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596- (NSString *)stringByDecodingXMLEntities &#123; NSUInteger myLength = [self length]; NSUInteger ampIndex = [self rangeOfString:@&quot;&amp;&quot; options:NSLiteralSearch].location; // Short-circuit if there are no ampersands. if (ampIndex == NSNotFound) &#123; return self; &#125; // Make result string with some extra capacity. NSMutableString *result = [NSMutableString stringWithCapacity:(myLength * 1.25)]; // First iteration doesn&apos;t need to scan to &amp; since we did that already, but for code simplicity&apos;s sake we&apos;ll do it again with the scanner. NSScanner *scanner = [NSScanner scannerWithString:self]; [scanner setCharactersToBeSkipped:nil]; NSCharacterSet *boundaryCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@&quot; \\t\\n\\r;&quot;]; do &#123; // Scan up to the next entity or the end of the string. NSString *nonEntityString; if ([scanner scanUpToString:@&quot;&amp;&quot; intoString:&amp;nonEntityString]) &#123; [result appendString:nonEntityString]; &#125; if ([scanner isAtEnd]) &#123; goto finish; &#125; // Scan either a HTML or numeric character entity reference. if ([scanner scanString:@&quot;&amp;&quot; intoString:NULL]) [result appendString:@&quot;&amp;&quot;]; else if ([scanner scanString:@&quot;&apos;&quot; intoString:NULL]) [result appendString:@&quot;&apos;&quot;]; else if ([scanner scanString:@&quot;&quot;&quot; intoString:NULL]) [result appendString:@&quot;\\&quot;&quot;]; else if ([scanner scanString:@&quot;&lt;&quot; intoString:NULL]) [result appendString:@&quot;&lt;&quot;]; else if ([scanner scanString:@&quot;&gt;&quot; intoString:NULL]) [result appendString:@&quot;&gt;&quot;]; else if ([scanner scanString:@&quot;&amp;#&quot; intoString:NULL]) &#123; BOOL gotNumber; unsigned charCode; NSString *xForHex = @&quot;&quot;; // Is it hex or decimal? if ([scanner scanString:@&quot;x&quot; intoString:&amp;xForHex]) &#123; gotNumber = [scanner scanHexInt:&amp;charCode]; &#125; else &#123; gotNumber = [scanner scanInt:(int*)&amp;charCode]; &#125; if (gotNumber) &#123; [result appendFormat:@&quot;%C&quot;, charCode]; [scanner scanString:@&quot;;&quot; intoString:NULL]; &#125; else &#123; NSString *unknownEntity = @&quot;&quot;; [scanner scanUpToCharactersFromSet:boundaryCharacterSet intoString:&amp;unknownEntity]; [result appendFormat:@&quot;&amp;#%@%@&quot;, xForHex, unknownEntity]; //[scanner scanUpToString:@&quot;;&quot; intoString:&amp;unknownEntity]; //[result appendFormat:@&quot;&amp;#%@%@;&quot;, xForHex, unknownEntity]; NSLog(@&quot;Expected numeric character entity but got &amp;#%@%@;&quot;, xForHex, unknownEntity); &#125; &#125; else &#123; NSString *amp; [scanner scanString:@&quot;&amp;&quot; intoString:&amp;amp]; //an isolated &amp; symbol [result appendString:amp]; /* NSString *unknownEntity = @&quot;&quot;; [scanner scanUpToString:@&quot;;&quot; intoString:&amp;unknownEntity]; NSString *semicolon = @&quot;&quot;; [scanner scanString:@&quot;;&quot; intoString:&amp;semicolon]; [result appendFormat:@&quot;%@%@&quot;, unknownEntity, semicolon]; NSLog(@&quot;Unsupported XML character entity %@%@&quot;, unknownEntity, semicolon); */ &#125; &#125; while (![scanner isAtEnd]); finish: return result;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"SDWebImage更新图片缓存的方法","slug":"iOS/SDWebImage更新图片缓存的方法","date":"2016-11-20T03:26:00.000Z","updated":"2017-03-24T02:25:28.000Z","comments":true,"path":"2016/11/20/iOS/SDWebImage更新图片缓存的方法/","link":"","permalink":"http://yoursite.com/2016/11/20/iOS/SDWebImage更新图片缓存的方法/","excerpt":"","text":"##SDWebImage加载图片，在图片链接相同但图片内容发生变更时，SDWebImage 并不会加载新的图片。此时的解决方案为设置SDWebImage 的option参数为SDWebImageRefreshCached。具体如下图：","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Swift怎么通过类名字符串来创建一个类","slug":"iOS/Swift怎么通过类名字符串来创建一个类","date":"2016-09-20T03:26:00.000Z","updated":"2017-03-24T02:24:36.000Z","comments":true,"path":"2016/09/20/iOS/Swift怎么通过类名字符串来创建一个类/","link":"","permalink":"http://yoursite.com/2016/09/20/iOS/Swift怎么通过类名字符串来创建一个类/","excerpt":"","text":"OC中可以直接通过类名的字符串转换成对应的类来操作,但是Swift中必须用到命名空间,也就是说Swift中通过字符串获取类的方式为1234567891011let namespace = NSBundle.mainBundle().infoDictionary![&quot;CFBundleExecutable&quot;]guard ((namespace as? String) != nil) else&#123;return &#125;let modelClass : AnyClass? = NSClassFromString((namespace as? String)!+&quot;.&quot;+modelClassStr)let baseModel = modelClass?.alloc()","categories":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}